{
  "version": 3,
  "sources": ["../src/core/graphAutocompleteCore.js"],
  "sourcesContent": ["import YAML from 'js-yaml';\n\nexport const INDENT_SIZE = 2;\n\nconst FORBIDDEN_AUTOCOMPLETE_KEYS = new Set(['id']);\nconst ROOT_SECTION_ALIASES = new Map([['edges', 'links']]);\n\nexport const NODE_TYPE_SUGGESTIONS = [\n  'router',\n  'switch',\n  'mpls',\n  'vpn',\n  'firewall',\n  'cloud',\n  'datacenter',\n  'azure',\n  'internet',\n  'cpe',\n  'database',\n  'server',\n  'host',\n  'ran',\n  'radio',\n  'splitter',\n  'devices',\n  'satelliteuplink',\n  'satellite',\n  'broadcast',\n  'lan',\n  'diagnostics',\n  'analytics',\n  'monitor',\n  'logging',\n  'iam',\n  'idea',\n  'tools',\n  'cctv',\n  'process',\n  'cooling',\n  'security',\n  'console',\n  'gis',\n  'city',\n  'settlement',\n  'sdu',\n  'mdu',\n  'company',\n  'farm',\n  'airport',\n  'mine',\n  'fieldservice',\n  'facility',\n  'energy',\n  'transmission',\n  'ip',\n  'mobilecore',\n  'access',\n  'operation',\n  'controller',\n  'product',\n  'consumer',\n  'fortinet',\n  'juniper',\n  'ericsson',\n  'huawei',\n  'cisco',\n  'mikrotik',\n];\n\nexport const LINK_TYPE_SUGGESTIONS = ['directed', 'undirected', 'association', 'dependency', 'generalization', 'none'];\n\nexport const DEFAULT_AUTOCOMPLETE_SPEC = {\n  rootSections: ['nodes', 'links'],\n  node: {\n    orderedKeys: ['name', 'type', 'ports', 'nodes', 'links'],\n    requiredKeys: ['name'],\n    entryStartKey: 'name',\n  },\n  link: {\n    orderedKeys: ['from', 'to', 'label', 'type'],\n    requiredKeys: ['from', 'to'],\n    entryStartKey: 'from',\n  },\n};\n\nconst KEY_DOCUMENTATION = {\n  nodes: 'Collection of graph nodes. Supports nested nodes and nested links.',\n  links: 'Collection of graph links/edges. Use from/to as node[:port] references.',\n  name: 'Display name for a node. Also used as a default endpoint identifier.',\n  type: 'Domain node/link type. Node types are schema-driven plus built-in defaults.',\n  from: 'Link source endpoint in node or node:port format.',\n  to: 'Link destination endpoint in node or node:port format.',\n  label: 'Optional display label for links.',\n  ports: 'Port definitions for node endpoints.',\n};\n\nexport function createEmptyCompletionMetaCache() {\n  return {\n    version: null,\n    text: '',\n    meta: {\n      lines: [''],\n      entities: { nodeNames: [], portsByNode: new Map() },\n      rootSectionPresence: new Set(),\n    },\n  };\n}\n\nexport function lineIndent(line) {\n  const match = String(line || '').match(/^(\\s*)/);\n  return match ? match[1].length : 0;\n}\n\nfunction previousNonEmptyLine(lines, startIndex) {\n  for (let i = startIndex; i >= 0; i -= 1) {\n    const line = lines[i] || '';\n    if (!line.trim()) {\n      continue;\n    }\n    return { line, index: i };\n  }\n  return null;\n}\n\nfunction rootContentBounds(lines) {\n  let firstNonEmpty = -1;\n  let lastNonEmpty = -1;\n  for (let i = 0; i < lines.length; i += 1) {\n    if (!(lines[i] || '').trim()) {\n      continue;\n    }\n    if (firstNonEmpty < 0) {\n      firstNonEmpty = i;\n    }\n    lastNonEmpty = i;\n  }\n  return { firstNonEmpty, lastNonEmpty };\n}\n\nexport function isRootBoundaryEmptyLine(lines, lineIndex) {\n  if (lineIndex < 0 || lineIndex >= lines.length) {\n    return false;\n  }\n  if ((lines[lineIndex] || '').trim().length > 0) {\n    return false;\n  }\n  const { firstNonEmpty, lastNonEmpty } = rootContentBounds(lines);\n  if (firstNonEmpty < 0 || lastNonEmpty < 0) {\n    return false;\n  }\n  return lineIndex < firstNonEmpty || lineIndex > lastNonEmpty;\n}\n\nfunction keyFromLine(line) {\n  const match = String(line || '').trim().match(/^(?:-\\s*)?([a-zA-Z_][a-zA-Z0-9_-]*)\\s*:/);\n  return match ? match[1] : null;\n}\n\nexport function inferYamlSection(lines, lineIndex, indent) {\n  for (let i = lineIndex; i >= 0; i -= 1) {\n    const text = lines[i];\n    const match = text.match(/^(\\s*)(nodes|links|edges)\\s*:\\s*$/);\n    if (!match) {\n      continue;\n    }\n    const sectionIndent = match[1].length;\n    if (sectionIndent < indent || i === lineIndex) {\n      const normalizedSection = ROOT_SECTION_ALIASES.get(match[2]) || match[2];\n      return { section: normalizedSection, sectionIndent };\n    }\n  }\n  return { section: 'root', sectionIndent: 0 };\n}\n\nfunction isContinuationLineAfterTerminalKey(lines, lineNumber, section, itemIndent) {\n  const safeLineIndex = Math.max(0, lineNumber - 1);\n  const currentLine = lines[safeLineIndex] || '';\n  if (currentLine.trim().length > 0) {\n    return false;\n  }\n  if (lineIndent(currentLine) <= itemIndent) {\n    return false;\n  }\n\n  const previous = previousNonEmptyLine(lines, safeLineIndex - 1);\n  if (!previous) {\n    return false;\n  }\n  if (lineIndent(previous.line) < itemIndent) {\n    return false;\n  }\n\n  const previousKey = keyFromLine(previous.line);\n  if (!previousKey) {\n    return false;\n  }\n  const terminalKey = section === 'nodes' ? 'type' : section === 'links' ? 'type' : null;\n  return terminalKey === previousKey;\n}\n\nexport function getYamlAutocompleteContext(text, lineNumber, column) {\n  const lines = text.split('\\n');\n  while (lineNumber > lines.length) {\n    lines.push('');\n  }\n  const safeLineNumber = Math.max(1, Math.min(lineNumber, lines.length));\n  const line = lines[safeLineNumber - 1] || '';\n  const safeColumn = Math.max(1, Math.min(column, line.length + 1));\n  const leftText = line.slice(0, safeColumn - 1);\n  const trimmedLeft = leftText.trim();\n  const indent = lineIndent(line);\n  const sectionInfo = inferYamlSection(lines, safeLineNumber - 1, indent);\n  const section = sectionInfo.section;\n  const itemIndent = sectionInfo.sectionIndent + INDENT_SIZE;\n\n  if (section === 'root' && isRootBoundaryEmptyLine(lines, safeLineNumber - 1)) {\n    return { kind: 'rootItemKey', section: 'root', prefix: '' };\n  }\n  if (section !== 'root' && isContinuationLineAfterTerminalKey(lines, safeLineNumber, section, itemIndent)) {\n    return { kind: 'itemKey', section, prefix: '' };\n  }\n\n  const dashTypeMatch = trimmedLeft.match(/^-\\s*type:\\s*([a-zA-Z0-9_-]*)$/);\n  const typeMatch = trimmedLeft.match(/^type:\\s*([a-zA-Z0-9_-]*)$/);\n  const typeValueMatch = dashTypeMatch || typeMatch;\n  if (typeValueMatch && section === 'nodes') {\n    return { kind: 'nodeTypeValue', section, prefix: typeValueMatch[1] || '' };\n  }\n  if (typeValueMatch && section === 'links') {\n    return { kind: 'linkTypeValue', section, prefix: typeValueMatch[1] || '' };\n  }\n\n  const endpointMatch = trimmedLeft.match(/^(?:-\\s*)?(from|to):\\s*([^\\s]*)$/);\n  if (endpointMatch && section === 'links') {\n    return {\n      kind: 'endpointValue',\n      section,\n      endpoint: endpointMatch[1],\n      prefix: endpointMatch[2] || '',\n    };\n  }\n\n  const listKeyMatch = trimmedLeft.match(/^-\\s*([a-zA-Z_][a-zA-Z0-9_-]*)?$/);\n  if (\n    section !== 'root' &&\n    (listKeyMatch || (indent <= itemIndent && (trimmedLeft === '' || /^[a-zA-Z_][a-zA-Z0-9_-]*$/.test(trimmedLeft))))\n  ) {\n    return {\n      kind: 'itemKey',\n      section,\n      prefix: listKeyMatch ? listKeyMatch[1] || '' : trimmedLeft,\n    };\n  }\n\n  const keyMatch = trimmedLeft.match(/^([a-zA-Z_][a-zA-Z0-9_-]*)?$/);\n  if (keyMatch) {\n    return {\n      kind: section === 'root' ? 'rootKey' : 'key',\n      section,\n      prefix: keyMatch[1] || '',\n    };\n  }\n\n  return { kind: 'none', section, prefix: '' };\n}\n\nfunction extractKeyFromLine(line) {\n  const match = line.trimStart().match(/^(?:-\\s*)?([a-zA-Z_][a-zA-Z0-9_-]*)\\s*:/);\n  return match ? match[1] : null;\n}\n\nfunction collectCurrentObjectKeys(lines, lineIndex, section, endLineIndex = lines.length - 1) {\n  if (section !== 'nodes' && section !== 'links') {\n    return [];\n  }\n\n  let start = lineIndex;\n  let objectIndent = null;\n  for (let i = lineIndex; i >= 0; i -= 1) {\n    const line = lines[i] || '';\n    const trimmed = line.trim();\n    if (!trimmed) {\n      continue;\n    }\n    const indent = lineIndent(line);\n\n    if (/^-\\s*/.test(trimmed)) {\n      start = i;\n      objectIndent = indent;\n      break;\n    }\n  }\n\n  if (objectIndent === null) {\n    return [];\n  }\n\n  const keys = [];\n  for (let i = start; i <= endLineIndex && i < lines.length; i += 1) {\n    const line = lines[i] || '';\n    const trimmed = line.trim();\n    if (!trimmed) {\n      continue;\n    }\n    const indent = lineIndent(line);\n\n    if (i > start && indent <= objectIndent && /^-\\s*/.test(trimmed)) {\n      break;\n    }\n    if (i > start && indent < objectIndent) {\n      break;\n    }\n    if (indent > objectIndent + INDENT_SIZE) {\n      continue;\n    }\n\n    const key = extractKeyFromLine(line);\n    if (key) {\n      keys.push(key);\n    }\n  }\n\n  return [...new Set(keys)];\n}\n\nfunction findItemStartBackward(lines, lineIndex, section) {\n  if (section !== 'nodes' && section !== 'links') {\n    return -1;\n  }\n  for (let i = lineIndex; i >= 0; i -= 1) {\n    const line = lines[i] || '';\n    const trimmed = line.trim();\n    if (!trimmed) {\n      continue;\n    }\n    const indent = lineIndent(line);\n    const sectionInfo = inferYamlSection(lines, i, indent);\n    if (sectionInfo.section !== section) {\n      continue;\n    }\n    if (/^-\\s*/.test(trimmed)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction collectItemContextInfo(lines, lineIndex, section) {\n  const currentItemStart = findItemStartBackward(lines, lineIndex, section);\n  if (currentItemStart < 0) {\n    return { objectKeys: [], canContinue: false };\n  }\n\n  const currentItemKeys = collectCurrentObjectKeys(lines, currentItemStart, section, lineIndex);\n  if (currentItemKeys.length > 0) {\n    return { objectKeys: currentItemKeys, canContinue: true };\n  }\n\n  const currentLineTrimmed = (lines[currentItemStart] || '').trim();\n  if (!/^-\\s*$/.test(currentLineTrimmed)) {\n    return { objectKeys: [], canContinue: false };\n  }\n\n  const previousItemStart = findItemStartBackward(lines, currentItemStart - 1, section);\n  if (previousItemStart < 0) {\n    return { objectKeys: [], canContinue: false };\n  }\n\n  return {\n    objectKeys: collectCurrentObjectKeys(lines, previousItemStart, section, currentItemStart - 1),\n    canContinue: true,\n  };\n}\n\nfunction collectOrderedKeys(sectionSpec) {\n  const requiredKeys = Array.isArray(sectionSpec?.requiredKeys) ? sectionSpec.requiredKeys : [];\n  const orderedKeys = Array.isArray(sectionSpec?.orderedKeys) ? sectionSpec.orderedKeys : [];\n  const keys = [...requiredKeys, ...orderedKeys];\n  return [\n    ...new Set(\n      keys.filter(\n        (key) => typeof key === 'string' && key.trim() && !FORBIDDEN_AUTOCOMPLETE_KEYS.has(String(key).trim())\n      )\n    ),\n  ];\n}\n\nfunction normalizeSectionPrefix(prefix) {\n  return String(prefix || '')\n    .replace(/^-/, '')\n    .replace(/:$/, '')\n    .trim()\n    .toLowerCase();\n}\n\nfunction selectNextObjectKey(sectionSpec, usedKeys, prefix) {\n  const orderedKeys = collectOrderedKeys(sectionSpec);\n  const used = new Set(usedKeys || []);\n  const available = orderedKeys.filter((key) => !used.has(key));\n  const normalizedPrefix = normalizeSectionPrefix(prefix);\n\n  if (!normalizedPrefix) {\n    return available.length ? [available[0]] : [];\n  }\n  return available.filter((key) => key.toLowerCase().startsWith(normalizedPrefix)).slice(0, 1);\n}\n\nfunction sectionSpecFor(section, spec) {\n  if (section === 'nodes') {\n    return spec?.node || DEFAULT_AUTOCOMPLETE_SPEC.node;\n  }\n  if (section === 'links') {\n    return spec?.link || DEFAULT_AUTOCOMPLETE_SPEC.link;\n  }\n  return null;\n}\n\nfunction endpointSuggestions(prefix, entities, endpoint) {\n  const rawPrefix = String(prefix || '');\n  const normalizedPrefix = rawPrefix.toLowerCase();\n  const nodeNames = Array.isArray(entities?.nodeNames) ? entities.nodeNames : [];\n  if (normalizedPrefix.includes(':')) {\n    return [];\n  }\n\n  const hasExactNodeMatch =\n    normalizedPrefix.length > 0 && nodeNames.some((name) => String(name).toLowerCase() === normalizedPrefix);\n  if ((endpoint === 'from' || endpoint === 'to') && hasExactNodeMatch) {\n    return [':'];\n  }\n\n  return nodeNames.filter((name) => String(name).toLowerCase().startsWith(normalizedPrefix));\n}\n\nexport function getYamlAutocompleteSuggestions(context, meta = {}) {\n  const spec = meta.spec || DEFAULT_AUTOCOMPLETE_SPEC;\n  const nodeTypes =\n    Array.isArray(meta.nodeTypeSuggestions) && meta.nodeTypeSuggestions.length\n      ? meta.nodeTypeSuggestions\n      : NODE_TYPE_SUGGESTIONS;\n  const linkTypes =\n    Array.isArray(meta.linkTypeSuggestions) && meta.linkTypeSuggestions.length\n      ? meta.linkTypeSuggestions\n      : LINK_TYPE_SUGGESTIONS;\n\n  if (context.kind === 'nodeTypeValue') {\n    return nodeTypes.filter((item) => item.startsWith((context.prefix || '').toLowerCase()));\n  }\n  if (context.kind === 'linkTypeValue') {\n    return linkTypes.filter((item) => item.startsWith((context.prefix || '').toLowerCase()));\n  }\n\n  if (context.kind === 'endpointValue') {\n    return endpointSuggestions(context.prefix, meta.entities || { nodeNames: [], portsByNode: new Map() }, context.endpoint);\n  }\n\n  if (context.kind === 'rootKey') {\n    const prefix = normalizeSectionPrefix(context.prefix);\n    const present = meta.rootSectionPresence || new Set();\n    const rootSections = (spec.rootSections || DEFAULT_AUTOCOMPLETE_SPEC.rootSections).filter(\n      (item) => !present.has(item) && item.toLowerCase().startsWith(prefix)\n    );\n    return rootSections;\n  }\n\n  if (context.kind === 'rootItemKey') {\n    const rootSections = (spec.rootSections || DEFAULT_AUTOCOMPLETE_SPEC.rootSections).map((item) => String(item || ''));\n    const present = meta.rootSectionPresence || new Set();\n    return rootSections\n      .filter((item) => item && !present.has(item))\n      .map((item) => `- ${item}:`);\n  }\n\n  if (context.kind === 'itemKey') {\n    const sectionSpec = sectionSpecFor(context.section, spec);\n    const itemContextKeys = Array.isArray(meta.itemContextKeys) ? meta.itemContextKeys : [];\n    const canContinueItem = Boolean(meta.canContinueItemContext);\n    const startKey = sectionSpec?.entryStartKey || (context.section === 'nodes' ? 'name' : 'from');\n    const normalizedPrefix = normalizeSectionPrefix(context.prefix);\n\n    let continuationKeys = collectOrderedKeys(sectionSpec).filter((key) => key !== startKey);\n    if (context.section === 'nodes' && itemContextKeys.includes('type')) {\n      continuationKeys = [];\n    }\n    continuationKeys = continuationKeys.filter((key) => !itemContextKeys.includes(key));\n\n    const options = [{ label: `- ${startKey}`, key: startKey }];\n    if (canContinueItem) {\n      for (const key of continuationKeys) {\n        options.push({ label: `  ${key}`, key });\n      }\n    }\n\n    if (!normalizedPrefix) {\n      return options.map((option) => option.label);\n    }\n    return options\n      .filter((option) => option.key.toLowerCase().startsWith(normalizedPrefix))\n      .map((option) => option.label);\n  }\n\n  if (context.kind === 'key' && (context.section === 'nodes' || context.section === 'links')) {\n    const sectionSpec = sectionSpecFor(context.section, spec);\n    return selectNextObjectKey(sectionSpec, meta.objectKeys, context.prefix);\n  }\n\n  return [];\n}\n\nexport function computeIndentBackspaceDeleteCount(lineContent, column, indentSize = INDENT_SIZE) {\n  const safeLineContent = String(lineContent || '');\n  const caretIndex = Math.max(0, Math.min(column - 1, safeLineContent.length));\n  const before = safeLineContent.slice(0, caretIndex);\n  const after = safeLineContent.slice(caretIndex);\n  if (!before || before.trim().length > 0 || after.trim().length > 0) {\n    return 0;\n  }\n  const remainder = caretIndex % indentSize;\n  return remainder === 0 ? Math.min(indentSize, caretIndex) : remainder;\n}\n\nfunction collectGraphEntitiesFromParsed(parsed) {\n  const nodeNames = new Set();\n  const portsByNode = new Map();\n  const seen = new Set();\n  const pendingEndpoints = [];\n\n  function parseEndpoint(endpoint) {\n    if (typeof endpoint !== 'string') {\n      return null;\n    }\n    const [node, port] = endpoint.split(':');\n    if (!node) {\n      return null;\n    }\n    return { node, port: port || '' };\n  }\n\n  function visit(graphObj) {\n    if (!graphObj || typeof graphObj !== 'object') {\n      return;\n    }\n    if (seen.has(graphObj)) {\n      return;\n    }\n    seen.add(graphObj);\n\n    const nodes = Array.isArray(graphObj.nodes) ? graphObj.nodes : [];\n    const links = Array.isArray(graphObj.links) ? graphObj.links : Array.isArray(graphObj.edges) ? graphObj.edges : [];\n\n    for (const node of nodes) {\n      if (typeof node === 'string') {\n        nodeNames.add(node);\n        continue;\n      }\n      if (!node || typeof node !== 'object') {\n        continue;\n      }\n      if (typeof node.name === 'string') {\n        nodeNames.add(node.name);\n      }\n      visit(node);\n    }\n\n    for (const link of links) {\n      if (!link || typeof link !== 'object') {\n        continue;\n      }\n      pendingEndpoints.push(parseEndpoint(link.from), parseEndpoint(link.to));\n    }\n  }\n\n  visit(parsed);\n\n  for (const endpoint of pendingEndpoints) {\n    if (!endpoint || !endpoint.node || !endpoint.port) {\n      continue;\n    }\n    if (!nodeNames.has(endpoint.node)) {\n      continue;\n    }\n    if (!portsByNode.has(endpoint.node)) {\n      portsByNode.set(endpoint.node, new Set());\n    }\n    portsByNode.get(endpoint.node).add(endpoint.port);\n  }\n\n  return {\n    nodeNames: [...nodeNames].sort((a, b) => a.localeCompare(b)),\n    portsByNode,\n  };\n}\n\nexport function collectRootSectionPresence(lines, parsed) {\n  const present = new Set();\n  if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n    for (const key of Object.keys(parsed)) {\n      const normalized = ROOT_SECTION_ALIASES.get(key) || key;\n      if (normalized === 'nodes' || normalized === 'links') {\n        present.add(normalized);\n      }\n    }\n  }\n  if (present.size > 0) {\n    return present;\n  }\n\n  for (const line of lines) {\n    const match = line.match(/^(\\s*)(nodes|links|edges)\\s*:\\s*$/);\n    if (!match) {\n      continue;\n    }\n    if ((match[1] || '').length !== 0) {\n      continue;\n    }\n    const normalized = ROOT_SECTION_ALIASES.get(match[2]) || match[2];\n    if (normalized === 'nodes' || normalized === 'links') {\n      present.add(normalized);\n    }\n  }\n\n  return present;\n}\n\nexport function buildAutocompleteMetadata(text) {\n  const lines = text.split('\\n');\n  let entities = { nodeNames: [], portsByNode: new Map() };\n  let rootSectionPresence = collectRootSectionPresence(lines, null);\n\n  try {\n    const parsed = YAML.load(text);\n    entities = collectGraphEntitiesFromParsed(parsed);\n    rootSectionPresence = collectRootSectionPresence(lines, parsed);\n  } catch (_err) {\n    // Best effort only. Completion still works for structural keys.\n  }\n\n  return { lines, entities, rootSectionPresence };\n}\n\nexport function buildAutocompleteRuntimeFromMeta(text, lineNumber, column, meta) {\n  const context = getYamlAutocompleteContext(text, lineNumber, column);\n  const lineIndex = Math.max(0, Math.min(lineNumber - 1, meta.lines.length - 1));\n  const itemContextInfo =\n    context.kind === 'itemKey' && (context.section === 'nodes' || context.section === 'links')\n      ? collectItemContextInfo(meta.lines, lineIndex, context.section)\n      : { objectKeys: [], canContinue: false };\n\n  return {\n    context,\n    objectKeys:\n      context.kind === 'key' && (context.section === 'nodes' || context.section === 'links')\n        ? collectCurrentObjectKeys(meta.lines, lineIndex, context.section, lineIndex)\n        : [],\n    itemContextKeys: itemContextInfo.objectKeys,\n    canContinueItemContext: itemContextInfo.canContinue,\n    entities: meta.entities,\n  };\n}\n\nexport function buildCompletionDocumentation(label) {\n  return KEY_DOCUMENTATION[label] || '';\n}\n\nexport function markerFromDiagnostic(monaco, model, diagnostic) {\n  const maxLine = typeof model.getLineCount === 'function' ? model.getLineCount() : Number.POSITIVE_INFINITY;\n  const startLineNumber = Math.max(1, Math.min(maxLine, diagnostic.lineNumber || 1));\n  const endLineNumber = Math.max(startLineNumber, Math.min(maxLine, diagnostic.endLineNumber || startLineNumber));\n  const lineText = typeof model.getLineContent === 'function' ? model.getLineContent(startLineNumber) : '';\n  const minEndColumn = Math.max(2, (diagnostic.column || 1) + 1);\n  const startColumn = Math.max(1, diagnostic.column || 1);\n  const endColumn = Math.max(minEndColumn, Math.min(lineText.length + 1 || minEndColumn, diagnostic.endColumn || minEndColumn));\n\n  return {\n    severity:\n      diagnostic.severity === 'warning'\n        ? monaco.MarkerSeverity.Warning\n        : diagnostic.severity === 'info'\n          ? monaco.MarkerSeverity.Info\n          : monaco.MarkerSeverity.Error,\n    message: diagnostic.message,\n    source: diagnostic.source || 'GraphAutocompleteCore',\n    startLineNumber,\n    startColumn,\n    endLineNumber,\n    endColumn,\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
