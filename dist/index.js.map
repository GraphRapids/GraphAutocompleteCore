{
  "version": 3,
  "sources": ["../src/core/graphAutocompleteCore.js"],
  "sourcesContent": ["import YAML from 'js-yaml';\n\nexport const INDENT_SIZE = 2;\n\nconst FORBIDDEN_AUTOCOMPLETE_KEYS = new Set(['id']);\nconst ROOT_SECTION_ALIASES = new Map([['edges', 'links']]);\n\nexport const NODE_TYPE_SUGGESTIONS = [];\nexport const LINK_TYPE_SUGGESTIONS = [];\nexport const EMPTY_PROFILE_CATALOG = Object.freeze({\n  schemaVersion: 'v1',\n  profileId: '',\n  profileVersion: 0,\n  checksum: '',\n  nodeTypes: [],\n  linkTypes: [],\n});\n\nexport function normalizeCatalogValues(values = []) {\n  const result = [];\n  const seen = new Set();\n  for (const raw of values) {\n    const normalized = String(raw || '')\n      .trim()\n      .toLowerCase();\n    if (!normalized || seen.has(normalized)) {\n      continue;\n    }\n    seen.add(normalized);\n    result.push(normalized);\n  }\n  return result;\n}\n\nexport function createProfileCatalog(input = {}) {\n  return {\n    schemaVersion: String(input.schemaVersion || 'v1'),\n    profileId: String(input.profileId || ''),\n    profileVersion: Number.isFinite(input.profileVersion) ? Number(input.profileVersion) : 0,\n    checksum: String(input.checksum || ''),\n    nodeTypes: normalizeCatalogValues(input.nodeTypes),\n    linkTypes: normalizeCatalogValues(input.linkTypes),\n  };\n}\n\nexport const DEFAULT_AUTOCOMPLETE_SPEC = {\n  rootSections: ['nodes', 'links'],\n  node: {\n    orderedKeys: ['name', 'type', 'ports', 'nodes', 'links'],\n    requiredKeys: ['name'],\n    entryStartKey: 'name',\n  },\n  link: {\n    orderedKeys: ['from', 'to', 'label', 'type'],\n    requiredKeys: ['from', 'to'],\n    entryStartKey: 'from',\n  },\n};\n\nconst KEY_DOCUMENTATION = {\n  nodes: 'Collection of graph nodes. Supports nested nodes and nested links.',\n  links: 'Collection of graph links/edges. Use from/to as node[:port] references.',\n  name: 'Display name for a node. Also used as a default endpoint identifier.',\n  type: 'Domain node/link type. Type suggestions are profile-driven.',\n  from: 'Link source endpoint in node or node:port format.',\n  to: 'Link destination endpoint in node or node:port format.',\n  label: 'Optional display label for links.',\n  ports: 'Port definitions for node endpoints.',\n};\n\nexport function createEmptyCompletionMetaCache() {\n  return {\n    version: null,\n    text: '',\n    meta: {\n      lines: [''],\n      entities: { nodeNames: [], portsByNode: new Map() },\n      rootSectionPresence: new Set(),\n    },\n  };\n}\n\nexport function lineIndent(line) {\n  const match = String(line || '').match(/^(\\s*)/);\n  return match ? match[1].length : 0;\n}\n\nfunction previousNonEmptyLine(lines, startIndex) {\n  for (let i = startIndex; i >= 0; i -= 1) {\n    const line = lines[i] || '';\n    if (!line.trim()) {\n      continue;\n    }\n    return { line, index: i };\n  }\n  return null;\n}\n\nfunction rootContentBounds(lines) {\n  let firstNonEmpty = -1;\n  let lastNonEmpty = -1;\n  for (let i = 0; i < lines.length; i += 1) {\n    if (!(lines[i] || '').trim()) {\n      continue;\n    }\n    if (firstNonEmpty < 0) {\n      firstNonEmpty = i;\n    }\n    lastNonEmpty = i;\n  }\n  return { firstNonEmpty, lastNonEmpty };\n}\n\nexport function isRootBoundaryEmptyLine(lines, lineIndex) {\n  if (lineIndex < 0 || lineIndex >= lines.length) {\n    return false;\n  }\n  if ((lines[lineIndex] || '').trim().length > 0) {\n    return false;\n  }\n  const { firstNonEmpty, lastNonEmpty } = rootContentBounds(lines);\n  if (firstNonEmpty < 0 || lastNonEmpty < 0) {\n    return false;\n  }\n  return lineIndex < firstNonEmpty || lineIndex > lastNonEmpty;\n}\n\nfunction keyFromLine(line) {\n  const match = String(line || '').trim().match(/^(?:-\\s*)?([a-zA-Z_][a-zA-Z0-9_-]*)\\s*:/);\n  return match ? match[1] : null;\n}\n\nexport function inferYamlSection(lines, lineIndex, indent) {\n  for (let i = lineIndex; i >= 0; i -= 1) {\n    const text = lines[i];\n    const match = text.match(/^(\\s*)(nodes|links|edges)\\s*:\\s*$/);\n    if (!match) {\n      continue;\n    }\n    const sectionIndent = match[1].length;\n    if (sectionIndent < indent || i === lineIndex) {\n      const normalizedSection = ROOT_SECTION_ALIASES.get(match[2]) || match[2];\n      return { section: normalizedSection, sectionIndent };\n    }\n  }\n  return { section: 'root', sectionIndent: 0 };\n}\n\nfunction isContinuationLineAfterTerminalKey(lines, lineNumber, section, itemIndent) {\n  const safeLineIndex = Math.max(0, lineNumber - 1);\n  const currentLine = lines[safeLineIndex] || '';\n  if (currentLine.trim().length > 0) {\n    return false;\n  }\n  if (lineIndent(currentLine) <= itemIndent) {\n    return false;\n  }\n\n  const previous = previousNonEmptyLine(lines, safeLineIndex - 1);\n  if (!previous) {\n    return false;\n  }\n  if (lineIndent(previous.line) < itemIndent) {\n    return false;\n  }\n\n  const previousKey = keyFromLine(previous.line);\n  if (!previousKey) {\n    return false;\n  }\n  const terminalKey = section === 'nodes' ? 'type' : section === 'links' ? 'type' : null;\n  return terminalKey === previousKey;\n}\n\nexport function getYamlAutocompleteContext(text, lineNumber, column) {\n  const lines = text.split('\\n');\n  while (lineNumber > lines.length) {\n    lines.push('');\n  }\n  const safeLineNumber = Math.max(1, Math.min(lineNumber, lines.length));\n  const line = lines[safeLineNumber - 1] || '';\n  const safeColumn = Math.max(1, Math.min(column, line.length + 1));\n  const leftText = line.slice(0, safeColumn - 1);\n  const trimmedLeft = leftText.trim();\n  const indent = lineIndent(line);\n  const sectionInfo = inferYamlSection(lines, safeLineNumber - 1, indent);\n  const section = sectionInfo.section;\n  const itemIndent = sectionInfo.sectionIndent + INDENT_SIZE;\n\n  if (section === 'root' && isRootBoundaryEmptyLine(lines, safeLineNumber - 1)) {\n    return { kind: 'rootItemKey', section: 'root', prefix: '' };\n  }\n  if (section !== 'root' && isContinuationLineAfterTerminalKey(lines, safeLineNumber, section, itemIndent)) {\n    return { kind: 'itemKey', section, prefix: '' };\n  }\n\n  const dashTypeMatch = trimmedLeft.match(/^-\\s*type:\\s*([a-zA-Z0-9_-]*)$/);\n  const typeMatch = trimmedLeft.match(/^type:\\s*([a-zA-Z0-9_-]*)$/);\n  const typeValueMatch = dashTypeMatch || typeMatch;\n  if (typeValueMatch && section === 'nodes') {\n    return { kind: 'nodeTypeValue', section, prefix: typeValueMatch[1] || '' };\n  }\n  if (typeValueMatch && section === 'links') {\n    return { kind: 'linkTypeValue', section, prefix: typeValueMatch[1] || '' };\n  }\n\n  const endpointMatch = trimmedLeft.match(/^(?:-\\s*)?(from|to):\\s*([^\\s]*)$/);\n  if (endpointMatch && section === 'links') {\n    return {\n      kind: 'endpointValue',\n      section,\n      endpoint: endpointMatch[1],\n      prefix: endpointMatch[2] || '',\n    };\n  }\n\n  const listKeyMatch = trimmedLeft.match(/^-\\s*([a-zA-Z_][a-zA-Z0-9_-]*)?$/);\n  if (\n    section !== 'root' &&\n    (listKeyMatch || (indent <= itemIndent && (trimmedLeft === '' || /^[a-zA-Z_][a-zA-Z0-9_-]*$/.test(trimmedLeft))))\n  ) {\n    return {\n      kind: 'itemKey',\n      section,\n      prefix: listKeyMatch ? listKeyMatch[1] || '' : trimmedLeft,\n    };\n  }\n\n  const keyMatch = trimmedLeft.match(/^([a-zA-Z_][a-zA-Z0-9_-]*)?$/);\n  if (keyMatch) {\n    return {\n      kind: section === 'root' ? 'rootKey' : 'key',\n      section,\n      prefix: keyMatch[1] || '',\n    };\n  }\n\n  return { kind: 'none', section, prefix: '' };\n}\n\nfunction extractKeyFromLine(line) {\n  const match = line.trimStart().match(/^(?:-\\s*)?([a-zA-Z_][a-zA-Z0-9_-]*)\\s*:/);\n  return match ? match[1] : null;\n}\n\nfunction collectCurrentObjectKeys(lines, lineIndex, section, endLineIndex = lines.length - 1) {\n  if (section !== 'nodes' && section !== 'links') {\n    return [];\n  }\n\n  let start = lineIndex;\n  let objectIndent = null;\n  for (let i = lineIndex; i >= 0; i -= 1) {\n    const line = lines[i] || '';\n    const trimmed = line.trim();\n    if (!trimmed) {\n      continue;\n    }\n    const indent = lineIndent(line);\n\n    if (/^-\\s*/.test(trimmed)) {\n      start = i;\n      objectIndent = indent;\n      break;\n    }\n  }\n\n  if (objectIndent === null) {\n    return [];\n  }\n\n  const keys = [];\n  for (let i = start; i <= endLineIndex && i < lines.length; i += 1) {\n    const line = lines[i] || '';\n    const trimmed = line.trim();\n    if (!trimmed) {\n      continue;\n    }\n    const indent = lineIndent(line);\n\n    if (i > start && indent <= objectIndent && /^-\\s*/.test(trimmed)) {\n      break;\n    }\n    if (i > start && indent < objectIndent) {\n      break;\n    }\n    if (indent > objectIndent + INDENT_SIZE) {\n      continue;\n    }\n\n    const key = extractKeyFromLine(line);\n    if (key) {\n      keys.push(key);\n    }\n  }\n\n  return [...new Set(keys)];\n}\n\nfunction findItemStartBackward(lines, lineIndex, section) {\n  if (section !== 'nodes' && section !== 'links') {\n    return -1;\n  }\n  for (let i = lineIndex; i >= 0; i -= 1) {\n    const line = lines[i] || '';\n    const trimmed = line.trim();\n    if (!trimmed) {\n      continue;\n    }\n    const indent = lineIndent(line);\n    const sectionInfo = inferYamlSection(lines, i, indent);\n    if (sectionInfo.section !== section) {\n      continue;\n    }\n    if (/^-\\s*/.test(trimmed)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction collectItemContextInfo(lines, lineIndex, section) {\n  const currentItemStart = findItemStartBackward(lines, lineIndex, section);\n  if (currentItemStart < 0) {\n    return { objectKeys: [], canContinue: false };\n  }\n\n  const currentItemKeys = collectCurrentObjectKeys(lines, currentItemStart, section, lineIndex);\n  if (currentItemKeys.length > 0) {\n    return { objectKeys: currentItemKeys, canContinue: true };\n  }\n\n  const currentLineTrimmed = (lines[currentItemStart] || '').trim();\n  if (!/^-\\s*$/.test(currentLineTrimmed)) {\n    return { objectKeys: [], canContinue: false };\n  }\n\n  const previousItemStart = findItemStartBackward(lines, currentItemStart - 1, section);\n  if (previousItemStart < 0) {\n    return { objectKeys: [], canContinue: false };\n  }\n\n  return {\n    objectKeys: collectCurrentObjectKeys(lines, previousItemStart, section, currentItemStart - 1),\n    canContinue: true,\n  };\n}\n\nfunction collectOrderedKeys(sectionSpec) {\n  const requiredKeys = Array.isArray(sectionSpec?.requiredKeys) ? sectionSpec.requiredKeys : [];\n  const orderedKeys = Array.isArray(sectionSpec?.orderedKeys) ? sectionSpec.orderedKeys : [];\n  const keys = [...requiredKeys, ...orderedKeys];\n  return [\n    ...new Set(\n      keys.filter(\n        (key) => typeof key === 'string' && key.trim() && !FORBIDDEN_AUTOCOMPLETE_KEYS.has(String(key).trim())\n      )\n    ),\n  ];\n}\n\nfunction normalizeSectionPrefix(prefix) {\n  return String(prefix || '')\n    .replace(/^-/, '')\n    .replace(/:$/, '')\n    .trim()\n    .toLowerCase();\n}\n\nfunction selectNextObjectKey(sectionSpec, usedKeys, prefix) {\n  const orderedKeys = collectOrderedKeys(sectionSpec);\n  const used = new Set(usedKeys || []);\n  const available = orderedKeys.filter((key) => !used.has(key));\n  const normalizedPrefix = normalizeSectionPrefix(prefix);\n\n  if (!normalizedPrefix) {\n    return available.length ? [available[0]] : [];\n  }\n  return available.filter((key) => key.toLowerCase().startsWith(normalizedPrefix)).slice(0, 1);\n}\n\nfunction sectionSpecFor(section, spec) {\n  if (section === 'nodes') {\n    return spec?.node || DEFAULT_AUTOCOMPLETE_SPEC.node;\n  }\n  if (section === 'links') {\n    return spec?.link || DEFAULT_AUTOCOMPLETE_SPEC.link;\n  }\n  return null;\n}\n\nfunction endpointSuggestions(prefix, entities, endpoint) {\n  const rawPrefix = String(prefix || '');\n  const normalizedPrefix = rawPrefix.toLowerCase();\n  const nodeNames = Array.isArray(entities?.nodeNames) ? entities.nodeNames : [];\n  if (normalizedPrefix.includes(':')) {\n    return [];\n  }\n\n  const hasExactNodeMatch =\n    normalizedPrefix.length > 0 && nodeNames.some((name) => String(name).toLowerCase() === normalizedPrefix);\n  if ((endpoint === 'from' || endpoint === 'to') && hasExactNodeMatch) {\n    return [':'];\n  }\n\n  return nodeNames.filter((name) => String(name).toLowerCase().startsWith(normalizedPrefix));\n}\n\nexport function buildYamlSuggestionInsertText({\n  context,\n  suggestion,\n  spec = DEFAULT_AUTOCOMPLETE_SPEC,\n  indentSize = INDENT_SIZE,\n  lines = [],\n  lineNumber = 1,\n  currentLine = '',\n}) {\n  const normalizedItem = String(suggestion || '');\n  const trimmedItem = normalizedItem.trim();\n  const isItemStartLabel = /^-\\s+/.test(trimmedItem);\n  const suggestionKey = trimmedItem.replace(/^-\\s+/, '').trim();\n  const normalizedSuggestionKey = suggestionKey.replace(/:\\s*$/, '');\n  const safeLines = Array.isArray(lines) && lines.length > 0 ? lines : [String(currentLine || '')];\n  const safeLineIndex = Math.max(0, Math.min(Number(lineNumber) - 1, safeLines.length - 1));\n  const resolvedCurrentLine = String(currentLine || safeLines[safeLineIndex] || '');\n  const currentIndent = lineIndent(resolvedCurrentLine);\n\n  if (context.kind === 'rootKey') {\n    const nextKey =\n      normalizedItem === 'nodes'\n        ? spec.node.entryStartKey\n        : spec.link.entryStartKey;\n    return {\n      insertText: `${normalizedItem}:\\n${' '.repeat(indentSize)}- ${nextKey}: `,\n      insertAsSnippet: false,\n    };\n  }\n\n  if (context.kind === 'rootItemKey') {\n    const rootKey = normalizedSuggestionKey;\n    const nextKey =\n      rootKey === 'nodes'\n        ? spec.node.entryStartKey\n        : spec.link.entryStartKey;\n    return {\n      insertText: `${rootKey}:\\n${' '.repeat(indentSize)}- ${nextKey}: `,\n      insertAsSnippet: false,\n    };\n  }\n\n  if (context.kind === 'itemKey') {\n    const sectionInfo = inferYamlSection(safeLines, safeLineIndex, lineIndent(resolvedCurrentLine));\n    const desiredIndent = sectionInfo.sectionIndent + indentSize;\n    if (isItemStartLabel) {\n      return {\n        insertText: `${' '.repeat(desiredIndent)}- ${suggestionKey}: `,\n        insertAsSnippet: false,\n      };\n    }\n\n    const isCollectionKey = suggestionKey === 'nodes' || suggestionKey === 'links';\n    if (isCollectionKey) {\n      const nextKey =\n        suggestionKey === 'nodes'\n          ? spec.node.entryStartKey\n          : spec.link.entryStartKey;\n      const isBoundaryLineAtItemIndent = resolvedCurrentLine.trim().length === 0 && currentIndent === desiredIndent;\n      const shouldDedentToParentCollection = isBoundaryLineAtItemIndent && sectionInfo.sectionIndent > 0;\n      const collectionKeyIndent = shouldDedentToParentCollection ? sectionInfo.sectionIndent : desiredIndent + indentSize;\n      const collectionItemIndent = collectionKeyIndent + indentSize;\n      return {\n        insertText: `${' '.repeat(collectionKeyIndent)}${suggestionKey}:\\n${' '.repeat(collectionItemIndent)}- ${nextKey}: `,\n        insertAsSnippet: false,\n      };\n    }\n\n    return {\n      insertText: `${' '.repeat(desiredIndent + indentSize)}${suggestionKey}: `,\n      insertAsSnippet: false,\n    };\n  }\n\n  if (context.kind === 'key') {\n    if (trimmedItem === 'nodes' || trimmedItem === 'links') {\n      const nextKey =\n        trimmedItem === 'nodes'\n          ? spec.node.entryStartKey\n          : spec.link.entryStartKey;\n      return {\n        insertText: `${trimmedItem}:\\n${' '.repeat(indentSize)}- ${nextKey}: `,\n        insertAsSnippet: false,\n      };\n    }\n    return {\n      insertText: `${trimmedItem}: `,\n      insertAsSnippet: false,\n    };\n  }\n\n  if (context.kind === 'endpointValue' && normalizedItem === ':') {\n    return {\n      insertText: ':',\n      insertAsSnippet: false,\n    };\n  }\n\n  if (context.kind === 'nodeTypeValue' || context.kind === 'linkTypeValue') {\n    return {\n      insertText: `${normalizedItem}\\n$0`,\n      insertAsSnippet: true,\n    };\n  }\n\n  return {\n    insertText: normalizedItem,\n    insertAsSnippet: false,\n  };\n}\n\nexport function resolveCompletionCommandBehavior(context, suggestion) {\n  const normalizedItem = String(suggestion || '');\n  const trimmedItem = normalizedItem.trim();\n  const suggestionKey = trimmedItem.replace(/^\\-\\s+/, '').trim();\n  const normalizedSuggestionKey = suggestionKey.replace(/:\\s*$/, '');\n  const isKeyLikeContext = context.kind === 'key' || context.kind === 'itemKey';\n  const isTypeValueContext = context.kind === 'nodeTypeValue' || context.kind === 'linkTypeValue';\n  const isEndpointValueContext = context.kind === 'endpointValue';\n  const keyToken = context.kind === 'itemKey' || context.kind === 'rootItemKey' ? normalizedSuggestionKey : suggestion;\n  const shouldTriggerSuggest =\n    (isKeyLikeContext && ['type', 'from', 'to'].includes(keyToken)) ||\n    isTypeValueContext ||\n    (isEndpointValueContext && normalizedItem !== ':');\n\n  return {\n    keyToken,\n    shouldTriggerSuggest,\n    title: shouldTriggerSuggest\n      ? isTypeValueContext\n        ? 'Trigger Next Step Suggestions'\n        : keyToken === 'type'\n          ? 'Trigger Type Suggestions'\n          : 'Trigger Endpoint Suggestions'\n      : '',\n  };\n}\n\nexport function getYamlAutocompleteSuggestions(context, meta = {}) {\n  const spec = meta.spec || DEFAULT_AUTOCOMPLETE_SPEC;\n  const profileCatalog = createProfileCatalog(meta.profileCatalog || {});\n  const nodeTypes =\n    Array.isArray(meta.nodeTypeSuggestions) && meta.nodeTypeSuggestions.length\n      ? normalizeCatalogValues(meta.nodeTypeSuggestions)\n      : profileCatalog.nodeTypes.length\n        ? profileCatalog.nodeTypes\n        : NODE_TYPE_SUGGESTIONS;\n  const linkTypes =\n    Array.isArray(meta.linkTypeSuggestions) && meta.linkTypeSuggestions.length\n      ? normalizeCatalogValues(meta.linkTypeSuggestions)\n      : profileCatalog.linkTypes.length\n        ? profileCatalog.linkTypes\n        : LINK_TYPE_SUGGESTIONS;\n\n  if (context.kind === 'nodeTypeValue') {\n    return nodeTypes.filter((item) => item.startsWith((context.prefix || '').toLowerCase()));\n  }\n  if (context.kind === 'linkTypeValue') {\n    return linkTypes.filter((item) => item.startsWith((context.prefix || '').toLowerCase()));\n  }\n\n  if (context.kind === 'endpointValue') {\n    return endpointSuggestions(context.prefix, meta.entities || { nodeNames: [], portsByNode: new Map() }, context.endpoint);\n  }\n\n  if (context.kind === 'rootKey') {\n    const prefix = normalizeSectionPrefix(context.prefix);\n    const present = meta.rootSectionPresence || new Set();\n    const rootSections = (spec.rootSections || DEFAULT_AUTOCOMPLETE_SPEC.rootSections).filter(\n      (item) => !present.has(item) && item.toLowerCase().startsWith(prefix)\n    );\n    return rootSections;\n  }\n\n  if (context.kind === 'rootItemKey') {\n    const rootSections = (spec.rootSections || DEFAULT_AUTOCOMPLETE_SPEC.rootSections).map((item) => String(item || ''));\n    const present = meta.rootSectionPresence || new Set();\n    return rootSections\n      .filter((item) => item && !present.has(item))\n      .map((item) => `- ${item}:`);\n  }\n\n  if (context.kind === 'itemKey') {\n    const sectionSpec = sectionSpecFor(context.section, spec);\n    const itemContextKeys = Array.isArray(meta.itemContextKeys) ? meta.itemContextKeys : [];\n    const canContinueItem = Boolean(meta.canContinueItemContext);\n    const startKey = sectionSpec?.entryStartKey || (context.section === 'nodes' ? 'name' : 'from');\n    const normalizedPrefix = normalizeSectionPrefix(context.prefix);\n\n    let continuationKeys = collectOrderedKeys(sectionSpec).filter((key) => key !== startKey);\n    if (context.section === 'nodes' && itemContextKeys.includes('type')) {\n      continuationKeys = [];\n    }\n    continuationKeys = continuationKeys.filter((key) => !itemContextKeys.includes(key));\n\n    const options = [{ label: `- ${startKey}`, key: startKey }];\n    if (canContinueItem) {\n      for (const key of continuationKeys) {\n        options.push({ label: `  ${key}`, key });\n      }\n    }\n\n    if (!normalizedPrefix) {\n      return options.map((option) => option.label);\n    }\n    return options\n      .filter((option) => option.key.toLowerCase().startsWith(normalizedPrefix))\n      .map((option) => option.label);\n  }\n\n  if (context.kind === 'key' && (context.section === 'nodes' || context.section === 'links')) {\n    const sectionSpec = sectionSpecFor(context.section, spec);\n    return selectNextObjectKey(sectionSpec, meta.objectKeys, context.prefix);\n  }\n\n  return [];\n}\n\nexport function resolveAutocompleteMetadataCache({\n  text,\n  version = null,\n  cache = createEmptyCompletionMetaCache(),\n  latestDocumentState = null,\n}) {\n  if (cache.version === version && cache.text === text) {\n    return { meta: cache.meta, cache };\n  }\n\n  const meta =\n    latestDocumentState && latestDocumentState.text === text\n      ? {\n          lines: text.split('\\n'),\n          entities: latestDocumentState.entities,\n          rootSectionPresence: collectRootSectionPresence(text.split('\\n'), latestDocumentState.parsedGraph),\n        }\n      : buildAutocompleteMetadata(text);\n\n  return {\n    meta,\n    cache: {\n      version,\n      text,\n      meta,\n    },\n  };\n}\n\nexport function resolveYamlAutocompleteAtPosition({\n  text,\n  lineNumber,\n  column,\n  meta,\n  profileCatalog = EMPTY_PROFILE_CATALOG,\n  nodeTypeSuggestions = [],\n  linkTypeSuggestions = [],\n  spec = DEFAULT_AUTOCOMPLETE_SPEC,\n}) {\n  const runtime = buildAutocompleteRuntimeFromMeta(text, lineNumber, column, meta);\n  const suggestions = getYamlAutocompleteSuggestions(runtime.context, {\n    objectKeys: runtime.objectKeys,\n    itemContextKeys: runtime.itemContextKeys,\n    canContinueItemContext: runtime.canContinueItemContext,\n    entities: runtime.entities,\n    rootSectionPresence: meta.rootSectionPresence,\n    profileCatalog,\n    nodeTypeSuggestions,\n    linkTypeSuggestions,\n    spec,\n  });\n\n  return { runtime, suggestions };\n}\n\nexport function planYamlEnterKeyAction({ text, lineNumber, column, indentSize = INDENT_SIZE }) {\n  const lines = text.split('\\n');\n  while (lineNumber > lines.length) {\n    lines.push('');\n  }\n  const safeLineNumber = Math.max(1, Math.min(lineNumber, lines.length));\n  const currentLine = lines[safeLineNumber - 1] || '';\n  const context = getYamlAutocompleteContext(text, safeLineNumber, column);\n  const endpointValue = String(context.prefix || '').trim();\n  const valueHasColon = endpointValue.includes(':');\n  const portPart = valueHasColon ? endpointValue.split(':').slice(1).join(':').trim() : '';\n  const canAdvanceEndpoint = endpointValue.length > 0 && (!valueHasColon || portPart.length > 0);\n\n  if (\n    context.kind === 'endpointValue' &&\n    context.section === 'links' &&\n    (context.endpoint === 'from' || context.endpoint === 'to') &&\n    canAdvanceEndpoint\n  ) {\n    const baseIndent = lineIndent(currentLine);\n    const nextIndent =\n      context.endpoint === 'from'\n        ? /^\\s*-\\s*/.test(currentLine)\n          ? baseIndent + indentSize\n          : baseIndent\n        : Math.max(0, baseIndent - indentSize);\n\n    if (context.endpoint === 'from') {\n      return {\n        shouldHandle: true,\n        editId: 'link-from-next-to',\n        insertText: `\\n${' '.repeat(nextIndent)}to: `,\n        triggerSource: 'enter-next-to',\n      };\n    }\n\n    return {\n      shouldHandle: true,\n      editId: 'link-to-next-step',\n      insertText: `\\n${' '.repeat(nextIndent)}`,\n      triggerSource: 'enter-next-to',\n    };\n  }\n\n  const trimmedCurrentLine = currentLine.trim();\n  const linkLabelValueMatch = trimmedCurrentLine.match(/^(?:-\\s*)?label:\\s*(.+)$/);\n  if (\n    context.section === 'links' &&\n    linkLabelValueMatch &&\n    String(linkLabelValueMatch[1] || '').trim().length > 0\n  ) {\n    const baseIndent = lineIndent(currentLine);\n    const nextIndent = /^\\s*-\\s*/.test(currentLine) ? baseIndent : Math.max(indentSize, baseIndent - indentSize);\n    return {\n      shouldHandle: true,\n      editId: 'link-label-next-step',\n      insertText: `\\n${' '.repeat(nextIndent)}`,\n      triggerSource: 'enter-after-label',\n    };\n  }\n\n  return {\n    shouldHandle: false,\n    editId: '',\n    insertText: '',\n    triggerSource: 'enter',\n  };\n}\n\nexport function planYamlBackspaceKeyAction({ text, lineNumber, column, indentSize = INDENT_SIZE }) {\n  const lines = text.split('\\n');\n  while (lineNumber > lines.length) {\n    lines.push('');\n  }\n\n  const safeLineNumber = Math.max(1, Math.min(lineNumber, lines.length));\n  const currentLine = lines[safeLineNumber - 1] || '';\n  const currentLineIndex = safeLineNumber - 1;\n  const currentLineIndent = lineIndent(currentLine);\n  const currentSection = inferYamlSection(lines, currentLineIndex, currentLineIndent).section;\n  const shouldUseRootBoundaryHandling = isRootBoundaryEmptyLine(lines, currentLineIndex) && currentSection === 'root';\n\n  if (shouldUseRootBoundaryHandling) {\n    return {\n      shouldHandle: true,\n      editId: 'root-boundary-backspace',\n      deleteStartColumn: 1,\n      deleteEndColumn: Math.max(1, column),\n      triggerSource: 'backspace-root-boundary',\n    };\n  }\n\n  const deleteCount = computeIndentBackspaceDeleteCount(currentLine, column, indentSize);\n  if (deleteCount <= 0) {\n    return {\n      shouldHandle: false,\n      editId: '',\n      deleteStartColumn: column,\n      deleteEndColumn: column,\n      triggerSource: 'backspace',\n    };\n  }\n\n  return {\n    shouldHandle: true,\n    editId: 'indent-backspace',\n    deleteStartColumn: Math.max(1, column - deleteCount),\n    deleteEndColumn: column,\n    triggerSource: 'backspace',\n  };\n}\n\nexport function computeIndentBackspaceDeleteCount(lineContent, column, indentSize = INDENT_SIZE) {\n  const safeLineContent = String(lineContent || '');\n  const caretIndex = Math.max(0, Math.min(column - 1, safeLineContent.length));\n  const before = safeLineContent.slice(0, caretIndex);\n  const after = safeLineContent.slice(caretIndex);\n  if (!before || before.trim().length > 0 || after.trim().length > 0) {\n    return 0;\n  }\n  const remainder = caretIndex % indentSize;\n  return remainder === 0 ? Math.min(indentSize, caretIndex) : remainder;\n}\n\nfunction collectGraphEntitiesFromParsed(parsed) {\n  const nodeNames = new Set();\n  const portsByNode = new Map();\n  const seen = new Set();\n  const pendingEndpoints = [];\n\n  function parseEndpoint(endpoint) {\n    if (typeof endpoint !== 'string') {\n      return null;\n    }\n    const [node, port] = endpoint.split(':');\n    if (!node) {\n      return null;\n    }\n    return { node, port: port || '' };\n  }\n\n  function visit(graphObj) {\n    if (!graphObj || typeof graphObj !== 'object') {\n      return;\n    }\n    if (seen.has(graphObj)) {\n      return;\n    }\n    seen.add(graphObj);\n\n    const nodes = Array.isArray(graphObj.nodes) ? graphObj.nodes : [];\n    const links = Array.isArray(graphObj.links) ? graphObj.links : Array.isArray(graphObj.edges) ? graphObj.edges : [];\n\n    for (const node of nodes) {\n      if (typeof node === 'string') {\n        nodeNames.add(node);\n        continue;\n      }\n      if (!node || typeof node !== 'object') {\n        continue;\n      }\n      if (typeof node.name === 'string') {\n        nodeNames.add(node.name);\n      }\n      visit(node);\n    }\n\n    for (const link of links) {\n      if (!link || typeof link !== 'object') {\n        continue;\n      }\n      pendingEndpoints.push(parseEndpoint(link.from), parseEndpoint(link.to));\n    }\n  }\n\n  visit(parsed);\n\n  for (const endpoint of pendingEndpoints) {\n    if (!endpoint || !endpoint.node || !endpoint.port) {\n      continue;\n    }\n    if (!nodeNames.has(endpoint.node)) {\n      continue;\n    }\n    if (!portsByNode.has(endpoint.node)) {\n      portsByNode.set(endpoint.node, new Set());\n    }\n    portsByNode.get(endpoint.node).add(endpoint.port);\n  }\n\n  return {\n    nodeNames: [...nodeNames].sort((a, b) => a.localeCompare(b)),\n    portsByNode,\n  };\n}\n\nexport function collectRootSectionPresence(lines, parsed) {\n  const present = new Set();\n  if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {\n    for (const key of Object.keys(parsed)) {\n      const normalized = ROOT_SECTION_ALIASES.get(key) || key;\n      if (normalized === 'nodes' || normalized === 'links') {\n        present.add(normalized);\n      }\n    }\n  }\n  if (present.size > 0) {\n    return present;\n  }\n\n  for (const line of lines) {\n    const match = line.match(/^(\\s*)(nodes|links|edges)\\s*:\\s*$/);\n    if (!match) {\n      continue;\n    }\n    if ((match[1] || '').length !== 0) {\n      continue;\n    }\n    const normalized = ROOT_SECTION_ALIASES.get(match[2]) || match[2];\n    if (normalized === 'nodes' || normalized === 'links') {\n      present.add(normalized);\n    }\n  }\n\n  return present;\n}\n\nexport function buildAutocompleteMetadata(text) {\n  const lines = text.split('\\n');\n  let entities = { nodeNames: [], portsByNode: new Map() };\n  let rootSectionPresence = collectRootSectionPresence(lines, null);\n\n  try {\n    const parsed = YAML.load(text);\n    entities = collectGraphEntitiesFromParsed(parsed);\n    rootSectionPresence = collectRootSectionPresence(lines, parsed);\n  } catch (_err) {\n    // Best effort only. Completion still works for structural keys.\n  }\n\n  return { lines, entities, rootSectionPresence };\n}\n\nexport function buildAutocompleteRuntimeFromMeta(text, lineNumber, column, meta) {\n  const context = getYamlAutocompleteContext(text, lineNumber, column);\n  const lineIndex = Math.max(0, Math.min(lineNumber - 1, meta.lines.length - 1));\n  const itemContextInfo =\n    context.kind === 'itemKey' && (context.section === 'nodes' || context.section === 'links')\n      ? collectItemContextInfo(meta.lines, lineIndex, context.section)\n      : { objectKeys: [], canContinue: false };\n\n  return {\n    context,\n    objectKeys:\n      context.kind === 'key' && (context.section === 'nodes' || context.section === 'links')\n        ? collectCurrentObjectKeys(meta.lines, lineIndex, context.section, lineIndex)\n        : [],\n    itemContextKeys: itemContextInfo.objectKeys,\n    canContinueItemContext: itemContextInfo.canContinue,\n    entities: meta.entities,\n  };\n}\n\nexport function buildCompletionDocumentation(label) {\n  return KEY_DOCUMENTATION[label] || '';\n}\n\nexport function markerFromDiagnostic(monaco, model, diagnostic) {\n  const maxLine = typeof model.getLineCount === 'function' ? model.getLineCount() : Number.POSITIVE_INFINITY;\n  const startLineNumber = Math.max(1, Math.min(maxLine, diagnostic.lineNumber || 1));\n  const endLineNumber = Math.max(startLineNumber, Math.min(maxLine, diagnostic.endLineNumber || startLineNumber));\n  const lineText = typeof model.getLineContent === 'function' ? model.getLineContent(startLineNumber) : '';\n  const minEndColumn = Math.max(2, (diagnostic.column || 1) + 1);\n  const startColumn = Math.max(1, diagnostic.column || 1);\n  const endColumn = Math.max(minEndColumn, Math.min(lineText.length + 1 || minEndColumn, diagnostic.endColumn || minEndColumn));\n\n  return {\n    severity:\n      diagnostic.severity === 'warning'\n        ? monaco.MarkerSeverity.Warning\n        : diagnostic.severity === 'info'\n          ? monaco.MarkerSeverity.Info\n          : monaco.MarkerSeverity.Error,\n    message: diagnostic.message,\n    source: diagnostic.source || 'GraphAutocompleteCore',\n    startLineNumber,\n    startColumn,\n    endLineNumber,\n    endColumn,\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
